题目一：[华为面试题] 1分2分5分的硬币三种，组合成1角，共有多少种组合
题目二：[创新工厂笔试题] 有1分，2分，5分，10分四种硬币，每种硬币数量无限，给定n分钱，有多少中组合可以组成n分钱
题目三：假设我们有8种不同面值的硬币｛1，2，5，10，20，50，100，200｝，用这些硬币组合够成一个给定的数值n。
例如n=200，那么一种可能的组合方式为 200 = 3 * 1 + 1＊2 + 1＊5 + 2＊20 + 1 * 50 + 1 * 100. 问总过有多少种可能的组合方式？

思路一：当然我们可以采用暴力枚举，各个系数可能的取值无非是x1 = {0, 1, ..., sum / V1}, x2 = {0, 1, ..., sum/ V2}等等。
这对于硬币种类数较小的题目还是可以应付的，比如华为和创新工厂的题目，但是复杂度也很高O（sum/V1 * sum/V2 * sum/V3 * ...）
int coinCombinations(vector<int> coins, int sum){
	
	

}

[思路2] 从上面的分析中我们也可以这么考虑，我们希望用m种硬币构成sum，根据最后一个硬币Vm的系数的取值为无非有这么几种情况，
xm分别取｛0, 1, 2, ..., sum/Vm｝，换句话说，上面分析中的等式和下面的几个等式的联合是等价的。
如果我们用二位数组表示dp[i][sum], 我们发现第i行的值全部依赖与i-1行的值，所以我们可以逐行求解该数组。
如果前0种硬币要组成sum，我们规定为dp[0][sum] = 0.

int coinCombinations(vector<int> coins, int sum){
	
	int n=coins.size();
	vector<vector<int> > dp(n+1, vector<int>(sum+1,0));

	for(int i=0;i<=n;i++)
		dp[i][0]=1;
	
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=sum;j++){
			for(int k=0;k<=sum/coins[i-1];k++){
				dp[i][j] += dp[i-1][j-k*coins[i-1]];
			}
		}
	}
	return dp[n][sum];
}